# -*- coding: utf-8 -*-
import os
import sys
import urllib3
import zipfile

import numpy as np
import tensorflow
from efficientnet.keras import center_crop_and_resize, preprocess_input
from efficientnet.keras import EfficientNetB3
from keras_applications.imagenet_utils import preprocess_input
from keras.callbacks import EarlyStopping, ModelCheckpoint
from keras.layers.core import Activation
from keras.models import Model
from tensorflow.keras import backend
from tensorflow.keras.preprocessing.image import img_to_array, load_img
from tensorflow.keras.utils import to_categorical, Sequence
from tensorflow.keras.optimizers import RMSprop
"""EN250.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zj7UuxQoOQerGA2GW818FZ2NtBUshV1Y
"""

###
# Useful paths
###
DATA_PATH = '/content/data'
PARASITIZED_PATH = os.path.join(DATA_PATH, 'cell_images/Parasitized')
UNINFECTED_PATH = os.path.join(DATA_PATH, 'cell_images/Uninfected')
MODEL_PATH = '/content/malaria.hdf5'

###
# Data metadata
###
DATA_FORMAT = 'channels_last'
backend.set_image_data_format(DATA_FORMAT)

###
# Model parameters
###
BATCH_SIZE = 32
EPOCHS = 100

"""# Data Preparation

Fetch the data from my server. This `data.zip`, once unpacked, has the structure of:
```
data/
  cell_images/
    Parasitized/
    Uninfected/
```
"""


###
# Download and extract the data
###
if not os.path.exists('/tmp/data.zip'):
    conn_pool = urllib3.PoolManager()
    req = conn_pool.request('GET', 'http://66.228.33.27/data.zip')
    with open('/tmp/data.zip', 'wb+') as fdata:
        fdata.write(req.data)
if not os.path.exists(DATA_PATH):
    with zipfile.ZipFile('/tmp/data.zip') as datazip:
        datazip.extractall(os.path.dirname(DATA_PATH))
if (not os.path.exists(PARASITIZED_PATH) or
        not os.path.exists(UNINFECTED_PATH)):
    raise RuntimeError('Provided data.zip has the wrong directory structure.')


def count_files(path): return sum([len(fs) for (_, _, fs) in os.walk(path)])


print(
    f"Parasitized\t{PARASITIZED_PATH}\t({count_files(PARASITIZED_PATH)} images)")
print(
    f"Uninfected\t{UNINFECTED_PATH}\t({count_files(UNINFECTED_PATH)} images)")

"""Now that data is loaded, we need to define a Keras `Sequence` class to handle loading the data from the directories with support for batching and multiprocessing."""


class MalariaSequence(Sequence):
    """Sequence that represents our Malaria dataset."""

    def _get_imgs(self, path):
        """Get list of image paths for a given `path`."""
        return [
            os.path.join(path, img)
            for img in os.listdir(path)
            if img.lower().endswith('.png')
        ]

    def _prepare_imgs(self, img_paths, image_size):
        """Process image paths into prepared images."""
        data = []
        size = len(img_paths)
        for n, img_path in enumerate(img_paths):
            sys.stdout.print(f"PROCESSED {n+1}/{size}\r")
            img = load_img(img_path, target_size=(image_size, image_size))
            img_arr = img_to_array(img, data_format=DATA_FORMAT)
            data.append(img_arr)
        print('')
        return data

    def __init__(
        self,
        parasitized_path,
        uninfected_path,
        image_size,
        batch_size=BATCH_SIZE,
        training=False
    ):
        parasitized_imgs = self._get_imgs(parasitized_path)
        uninfected_imgs = self._get_imgs(uninfected_path)
        all_imgs = np.array(
            self._prepare_imgs(parasitized_imgs) +
            self._prepare_imgs(uninfected_imgs)
        )
        labels = to_categorical(np.array(
            ([1] * len(parasitized_imgs)) +
            ([0] * len(uninfected_imgs))
        ), num_classes=2)
        imgs_idx = np.arange(all_imgs.shape[0])
        np.random.shuffle(imgs_idx)
        labels = labels[imgs_idx]

        self.batch_size = batch_size
        self.image_size = image_size
        if training:
            self.x = all_imgs[:(len(all_imgs) // 2)]
            self.y = labels[:(len(all_imgs) // 2)]
        else:
            self.x = all_imgs[(len(all_imgs) // 2):]
            self.y = labels[(len(all_imgs) // 2):]

    def __len__(self):
        return int(np.ceil(len(self.x) / float(self.batch_size)))

    def __getitem__(self, idx):
        batch_x = self.x[idx * self.batch_size:(idx + 1) * self.batch_size]
        batch_y = self.y[idx * self.batch_size:(idx + 1) * self.batch_size]

        return batch_x, batch_y


"""# Preparing the Model

The model needs some quick setup to use. We're also going to setup a model that is based on the activation layers of the EfficientNet model so we can see the outputs from the activation layers as images.
"""


# B0 variation of the EfficientNet model
# NOTE: Don't use pre-trained weights
with tensorflow.device('/device:GPU:0'):
    efficientnet_model = EfficientNetB3(weights=None, classes=2)
    target_image_size = efficientnet_model.input_shape[1]

    efficientnet_model.compile(
        loss='categorical_crossentropy',
        optimizer=RMSprop(
            learning_rate=0.256,
            decay=0.9,
            momentum=0.9,
            epsilon=1.0,
        ),
        metrics=['categorical_accuracy'],
    )

    activation_layers = [
        l.output
        for l in efficientnet_model.layers
        if isinstance(l, Activation)
    ]
    activiations_model = Model(
        inputs=efficientnet_model.input,
        outputs=activation_layers
    )

"""# Training the Model

Time to train the model! We will of course check for a saved HDF5 file of our model weights first to save time, then begin training.
"""

with tensorflow.device('/device:GPU:0'):
    if os.path.exists(MODEL_PATH):
        efficientnet_model.load_weights(MODEL_PATH)


with tensorflow.device('/device:GPU:0'):
    fitted_model = efficientnet_model.fit_generator(
        MalariaSequence(
            PARASITIZED_PATH,
            UNINFECTED_PATH,
            target_image_size,
            BATCH_SIZE,
            training=True,
        ),
        epochs=EPOCHS,
        verbose=1,
        callbacks=[
            ModelCheckpoint(
                MODEL_PATH,
                monitor='loss',
                save_best_only=True,
                save_weights_only=True,
                mode='min',
                period=1
            ),
            EarlyStopping(
                monitor='loss',
                min_delta=0.1,
                patience=3,
                mode='min',
                restore_best_weights=False,
            )
        ],
        shuffle=True,
        workers=os.cpu_count(),
        use_multiprocessing=True
    )

    evaluated_model = model.evaluate_generator(
        MalariaSequence(
            PARASITIZED_PATH,
            UNINFECTED_PATH,
            target_image_size,
            BATCH_SIZE
        ),
        verbose=1,
        workers=os.cpu_count(),
        use_multiprocessing=True
    )

    print("---")
    print(f"Loss: {evaluated_model[0]}")
    print(f"Accuracy: {evaluated_model[1]}")
